rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ========================================================================
    // HELPER FUNCTIONS
    // ========================================================================

    // Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Check if user owns the resource by owner_id field
    // STRICT: No legacy support - all documents must have valid owner_id
    function isResourceOwner() {
      return isAuthenticated() && resource.data.owner_id == request.auth.uid;
    }

    // Check if user is creating resource as themselves
    // CRITICAL SECURITY: Ensures owner_id in new document matches authenticated user
    function canCreateAsOwner() {
      return isAuthenticated() && request.resource.data.owner_id == request.auth.uid;
    }

    // Check if user owns the document by userId param (for user subcollections)
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // Check if user is an admin via custom claims
    function isAdmin() {
      return isAuthenticated() && request.auth.token.isAdmin == true;
    }

    // Check if user is an admin via Firestore document (fallback for web admin dashboard)
    function isAdminFromFirestore() {
      return isAuthenticated() && 
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    // Check if user owns the parent property
    // STRICT: No legacy support - property must have valid owner_id
    function isPropertyOwner(propertyId) {
      return isAuthenticated() &&
        get(/databases/$(database)/documents/properties/$(propertyId)).data.owner_id == request.auth.uid;
    }

    // ========================================================================
    // USERS COLLECTION
    // ========================================================================
    match /users/{userId} {
      // Admin dashboard needs to read all users for management
      allow read: if isOwner(userId) || isAdmin() || isAdminFromFirestore();

      // Users can update their own data, but NOT protected status fields.
      // Admins can update anything.
      // Protected fields: subscription status, trial dates, account type, lifetime license
      allow create: if (isOwner(userId) && !request.resource.data.keys().hasAny([
          'accountStatus', 'trialStartDate', 'trialExpiresAt',
          'statusChangedAt', 'statusChangedBy',
          'account_type', 'admin_override_account_type',
          'lifetime_license_granted_at', 'lifetime_license_granted_by'
        ])) || isAdmin() || isAdminFromFirestore();
      allow update: if (isOwner(userId) && !request.resource.data.diff(resource.data).affectedKeys().hasAny([
          'accountStatus', 'trialStartDate', 'trialExpiresAt',
          'statusChangedAt', 'statusChangedBy',
          'account_type', 'admin_override_account_type',
          'lifetime_license_granted_at', 'lifetime_license_granted_by'
        ])) || isAdmin() || isAdminFromFirestore();
      allow delete: if isAdmin() || isAdminFromFirestore(); // Users cannot delete themselves directly, must use Cloud Function

      // User data subcollection (profile, company, preferences)
      match /data/{document} {
        allow read: if isOwner(userId) || isAdmin();
        // Same logic as parent document: user can't change status fields.
        allow create: if (isOwner(userId) && !request.resource.data.keys().hasAny([
            'accountStatus', 'trialStartDate', 'trialExpiresAt',
            'statusChangedAt', 'statusChangedBy',
            'account_type', 'admin_override_account_type',
            'lifetime_license_granted_at', 'lifetime_license_granted_by'
          ])) || isAdmin();
        allow update: if (isOwner(userId) && !request.resource.data.diff(resource.data).affectedKeys().hasAny([
            'accountStatus', 'trialStartDate', 'trialExpiresAt',
            'statusChangedAt', 'statusChangedBy',
            'account_type', 'admin_override_account_type',
            'lifetime_license_granted_at', 'lifetime_license_granted_by'
          ])) || isAdmin();
        allow delete: if isOwner(userId) || isAdmin();
      }

      // Notifications subcollection
      // Path: users/{userId}/notifications/{notificationId}
      match /notifications/{notificationId} {
        allow read: if isOwner(userId);
        // Only Cloud Functions can create notifications (via Admin SDK)
        allow create: if false;
        // User can only update isRead field
        allow update: if isOwner(userId) &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isRead']);
        allow delete: if isOwner(userId);
      }

      // Rate limits - only Cloud Functions
      match /rate_limits/{action} {
        allow read: if false;
        allow write: if false;
      }

      // Security events subcollection - user login/logout/password change events
      // Users can create and read their own security events
      match /securityEvents/{eventId} {
        allow read: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update, delete: if false; // Immutable audit log
      }

      // Devices subcollection - user device tracking for session management
      match /devices/{deviceId} {
        allow read: if isOwner(userId);
        allow create, update: if isOwner(userId);
        allow delete: if isOwner(userId);
      }
    }

    // User Profiles - LEGACY collection (kept for backwards compatibility)
    match /user_profiles/{userId} {
      allow read: if isOwner(userId);
      allow write: if isOwner(userId);
    }

    // ========================================================================
    // PROPERTIES COLLECTION (MAIN STRUCTURE)
    // ========================================================================
    match /properties/{propertyId} {
      // PUBLIC READ: Properties are public data for widget booking functionality
      // Contains: name, description, location, amenities, images
      // NOTE: owner_id is visible but not sensitive (similar to Airbnb host profiles)
      allow read: if true;
      allow create: if canCreateAsOwner();
      allow update, delete: if isResourceOwner();

      // Units subcollection
      match /units/{unitId} {
        allow read: if true; // Public read for widget
        allow create, update, delete: if isPropertyOwner(propertyId);

        // Bookings subcollection
        // SECURITY FIX: Same rules as collection group (see below for full documentation)
        // - Owner: Read their own bookings (by owner_id)
        // - Widget: Read availability (by unit_id + status)
        // - Stripe: Poll payment (by stripe_session_id)
        // - Guest: View booking (by booking_reference)
        match /bookings/{bookingId} {
          allow read: if
            // Property owner can read ALL bookings in their property's units
            isPropertyOwner(propertyId) ||
            // Owner can read their own bookings (legacy check)
            (isAuthenticated() && resource.data.owner_id == request.auth.uid) ||
            // Widget calendar availability (public for calendar display)
            ('unit_id' in resource.data && 'status' in resource.data) ||
            // Stripe payment polling
            ('stripe_session_id' in resource.data && resource.data.stripe_session_id != null) ||
            // Guest booking view
            ('booking_reference' in resource.data && resource.data.booking_reference != null);
          // SECURITY: Write access requires property ownership AND owner_id integrity
          // This ensures an owner cannot create a booking with a fake owner_id
          allow create: if isPropertyOwner(propertyId) && request.resource.data.owner_id == request.auth.uid;
          allow update, delete: if isPropertyOwner(propertyId);
        }

        // Daily prices subcollection
        match /daily_prices/{dateStr} {
          allow read: if true; // Public read for widget price display
          allow create, update, delete: if isPropertyOwner(propertyId);
        }
      }

      // Widget settings subcollection
      match /widget_settings/{unitId} {
        allow read: if true; // Widget needs to read settings
        allow create, update, delete: if isPropertyOwner(propertyId);
      }

      // iCal events subcollection
      match /ical_events/{eventId} {
        allow read: if true; // Widget needs to read events for availability
        allow create, update, delete: if isPropertyOwner(propertyId);
      }

      // iCal feeds subcollection (feed configurations)
      // Path: properties/{propertyId}/ical_feeds/{feedId}
      match /ical_feeds/{feedId} {
        allow read: if isPropertyOwner(propertyId);
        allow create, update, delete: if isPropertyOwner(propertyId);
      }
    }

    // ========================================================================
    // COLLECTION GROUP QUERIES
    // Enables cross-property/cross-unit queries for dashboard and widget
    // ========================================================================

    // Collection group: units
    match /{path=**}/units/{unitId} {
      allow read: if true;
      // Writes via property_id lookup
      allow create: if isAuthenticated() &&
        ('property_id' in request.resource.data) &&
        get(/databases/$(database)/documents/properties/$(request.resource.data.property_id)).data.owner_id == request.auth.uid;
      allow update, delete: if isAuthenticated() &&
        ('property_id' in resource.data) &&
        get(/databases/$(database)/documents/properties/$(resource.data.property_id)).data.owner_id == request.auth.uid;
    }

    // Collection group: widget_settings
    match /{path=**}/widget_settings/{unitId} {
      allow read: if true;
      allow create: if isAuthenticated() &&
        ('property_id' in request.resource.data) &&
        get(/databases/$(database)/documents/properties/$(request.resource.data.property_id)).data.owner_id == request.auth.uid;
      allow update, delete: if isAuthenticated() &&
        ('property_id' in resource.data) &&
        get(/databases/$(database)/documents/properties/$(resource.data.property_id)).data.owner_id == request.auth.uid;
    }

    // Collection group: bookings
    // Used by: Owner dashboard, Guest bookings, Widget calendar, Stripe polling
    //
    // SECURITY: Multi-layered access control
    // Primary defense: owner_id check ensures users can only read their own bookings
    // Secondary: Specific query patterns for public/guest access (widget, stripe, booking view)
    //
    // ALLOWED ACCESS:
    // 1. Owner: Read their own bookings (by owner_id == auth.uid)
    //    - Works with ANY query pattern (unit_id filters, date ranges, etc.)
    //    - Realtime subscriptions, analytics, dashboard - all allowed
    // 2. Widget: Read availability ONLY (by unit_id + status) - public calendar
    // 3. Stripe: Poll payment status (by stripe_session_id)
    // 4. Guest: View own booking (by booking_reference)
    //
    // SECURITY NOTE: The owner_id check is the PRIMARY security boundary.
    // Even if attacker knows competitor's unit_ids and queries by them,
    // the rule will only return documents where owner_id == attacker's uid (none).
    match /{path=**}/bookings/{bookingId} {
      allow read: if
        // ADMIN: Full access for admin dashboard
        isAdmin() || isAdminFromFirestore() ||
        // PRIMARY SECURITY: Owner can read ONLY their own bookings
        // This works for ALL query patterns: realtime subscriptions, analytics, etc.
        // Even if query filters by unit_id/check_in, only owner's bookings are returned
        (isAuthenticated() && resource.data.owner_id == request.auth.uid) ||
        // PUBLIC: Widget calendar availability queries (unit_id + status)
        // SECURITY: Public for availability display, app code filters PII
        // Requires collection group index: unit_id ASC, status ASC
        ('unit_id' in resource.data && 'status' in resource.data) ||
        // PUBLIC: Stripe polling after payment (by stripe_session_id)
        // Requires collection group index: stripe_session_id ASC
        ('stripe_session_id' in resource.data && resource.data.stripe_session_id != null) ||
        // PUBLIC: Guest booking view (by booking_reference)
        // Requires collection group index: booking_reference ASC
        ('booking_reference' in resource.data && resource.data.booking_reference != null);
      // Writes go through specific subcollection path above
    }

    // Collection group: daily_prices
    // Used by: Price calculator, Availability checker
    match /{path=**}/daily_prices/{priceId} {
      allow read: if true;
      // Writes go through specific subcollection path above
    }

    // Collection group: ical_events
    // Used by: Availability checker (widget needs to check external calendar blocks)
    match /{path=**}/ical_events/{eventId} {
      allow read: if true;
      // Writes go through specific subcollection path above
    }

    // Collection group: ical_feeds
    // Used by: Scheduled sync Cloud Function, owner dashboard
    match /{path=**}/ical_feeds/{feedId} {
      // Read requires authentication - only owner should access their feeds
      allow read: if isAuthenticated() &&
        ('property_id' in resource.data) &&
        get(/databases/$(database)/documents/properties/$(resource.data.property_id)).data.owner_id == request.auth.uid;
      // Writes go through specific subcollection path above
    }

    // ========================================================================
    // DEPRECATED TOP-LEVEL COLLECTIONS
    // Kept for backward compatibility - migrate data to subcollections
    // TODO: Remove after confirming no legacy data remains
    // ========================================================================

    // DEPRECATED: Top-level units
    match /units/{unitId} {
      allow read: if true;
      allow create: if canCreateAsOwner();
      allow update, delete: if isResourceOwner();
    }

    // DEPRECATED: Top-level bookings
    // Same security rules as subcollection for consistency
    match /bookings/{bookingId} {
      allow read: if
        (isAuthenticated() && resource.data.owner_id == request.auth.uid) ||
        ('unit_id' in resource.data && 'status' in resource.data) ||
        ('stripe_session_id' in resource.data && resource.data.stripe_session_id != null) ||
        ('booking_reference' in resource.data && resource.data.booking_reference != null);
      allow create: if canCreateAsOwner();
      allow update, delete: if isResourceOwner();
    }

    // DEPRECATED: Top-level daily_prices
    match /daily_prices/{priceId} {
      allow read: if true;
      allow create: if canCreateAsOwner();
      allow update, delete: if isResourceOwner();
    }

    // DEPRECATED: Top-level ical_events
    match /ical_events/{eventId} {
      allow read: if true;
      allow create: if isAuthenticated() &&
        ('property_id' in request.resource.data) &&
        get(/databases/$(database)/documents/properties/$(request.resource.data.property_id)).data.owner_id == request.auth.uid;
      allow update, delete: if isAuthenticated() &&
        ('property_id' in resource.data) &&
        get(/databases/$(database)/documents/properties/$(resource.data.property_id)).data.owner_id == request.auth.uid;
    }

    // ========================================================================
    // OTHER COLLECTIONS
    // ========================================================================

    // Additional services - owners manage, anyone can read
    match /additional_services/{serviceId} {
      allow read: if true; // Widget needs to read services
      allow create: if canCreateAsOwner();
      allow update, delete: if isResourceOwner();
    }

    // Platform connections - external platform OAuth/API connections (Booking.com, Airbnb)
    // Owner can read/write their own connections
    match /platform_connections/{connectionId} {
      allow read: if isResourceOwner();
      allow create: if canCreateAsOwner();
      allow update, delete: if isResourceOwner();
    }

    // DEPRECATED: Root-level iCal feeds
    // iCal feeds are now stored as subcollections: properties/{propertyId}/ical_feeds/{feedId}
    // This rule is kept for backward compatibility with legacy data
    // TODO: Remove after confirming no legacy feeds remain
    match /ical_feeds/{feedId} {
      allow read: if isAuthenticated() && (
        resource == null ||
        get(/databases/$(database)/documents/properties/$(resource.data.property_id)).data.owner_id == request.auth.uid
      );
      allow create: if false; // DISABLED - use subcollection path
      allow update, delete: if isAuthenticated() &&
        ('property_id' in resource.data) &&
        get(/databases/$(database)/documents/properties/$(resource.data.property_id)).data.owner_id == request.auth.uid;
    }

    // Booking services - junction table for booking â†” additional_services
    // Only Cloud Functions create these (during booking creation)
    match /booking_services/{bookingServiceId} {
      allow read: if true; // Widget needs to read for price calculation
      allow create: if false; // Only Cloud Functions via Admin SDK
      allow update, delete: if isResourceOwner();
    }

    // ========================================================================
    // LOCKED COLLECTIONS - Only Cloud Functions via Admin SDK
    // ========================================================================

    // Login attempts - rate limiting
    match /loginAttempts/{email} {
      // SECURITY: allow read/write for rate limiting. 
      // rate_limit_service.dart uses sanitized email as doc ID.
      allow get, create, update: if true;
      allow list, delete: if false;
    }

    // Email verifications - OTP codes
    match /email_verifications/{emailHash} {
      allow read: if false;
      allow write: if false;
    }

    // Email templates - locked for future use
    match /email_templates/{templateId} {
      allow read: if false;
      allow write: if false;
    }

    // Tenants - locked for future use
    match /tenants/{tenantId} {
      allow read: if false;
      allow write: if false;
    }

    // App config - version control and force update settings
    // Read-only for authenticated users (mobile apps fetch version)
    // Only Cloud Functions can write (via Admin SDK)
    match /app_config/{platform} {
      allow read: if isAuthenticated(); // Any authenticated user can check version
      allow write: if false; // Only Cloud Functions via Admin SDK
    }

    // Security events - user login/logout/password change events
    // Users can create events for their own actions
    // Only Cloud Functions can read all events (via Admin SDK)
    match /security_events/{eventId} {
      allow read: if false; // Only Cloud Functions via Admin SDK
      allow create: if isAuthenticated(); // User can log their own security events
      allow update, delete: if false; // Immutable audit log
    }
  }
}
