import * as crypto from "crypto";
import {admin} from "./firebase";

/**
 * Token Configuration
 * Used for generating secure access tokens for booking lookup
 */
// Token generation constants
const TOKEN_BYTES = 32; // 256 bits of entropy
const TOKEN_ENCODING = "base64url" as const; // URL-safe, no padding
const HASH_ALGORITHM = "sha256" as const; // SHA-256 for storage

// Token expiration constants
const EXPIRATION_DAYS = 30; // Standard expiration after checkout
const EXTENDED_EXPIRATION_DAYS = 3650; // 10 years for old bookings

// Token validation constants
const MIN_TOKEN_LENGTH = 16; // Minimum reasonable token length
const MAX_TOKEN_LENGTH = 128; // Maximum reasonable token length
const HASH_LENGTH = 64; // SHA-256 = 64 hex chars

/**
 * Generate a secure access token for booking lookup
 * Token is a random 32-byte (256-bit) string that is hashed before storage
 *
 * SECURITY:
 * - 32 bytes = 256 bits of entropy (cryptographically secure)
 * - base64url encoding = URL-safe, no padding
 * - SHA-256 hashing for storage (prevents token leakage from DB)
 *
 * @returns Object with plaintext token (for email) and hashed token (for DB)
 */
export function generateBookingAccessToken(): {
  token: string;
  hashedToken: string;
} {
  // Generate random token using configured entropy
  // base64url encoding produces 43 characters (32 bytes â†’ 43 chars)
  const token = crypto
    .randomBytes(TOKEN_BYTES)
    .toString(TOKEN_ENCODING);

  // Hash token for secure storage
  const hashedToken = crypto
    .createHash(HASH_ALGORITHM)
    .update(token)
    .digest("hex");

  return {token, hashedToken};
}

/**
 * Calculate token expiration date
 *
 * EXPIRATION RULES:
 * - Future bookings: checkout + 30 days (standard)
 * - Past bookings: checkout + 10 years (extended access for historical records)
 *
 * This ensures guests can access old booking confirmations even years later
 */
export function calculateTokenExpiration(
  checkOutDate: admin.firestore.Timestamp
): admin.firestore.Timestamp {
  const now = new Date();
  const checkOut = checkOutDate.toDate();

  // Determine if this is an old booking (checkout already passed)
  const isOldBooking = checkOut < now;

  // Use extended expiration for old bookings to allow historical access
  const expirationDays = isOldBooking ?
    EXTENDED_EXPIRATION_DAYS :
    EXPIRATION_DAYS;

  const expiration = new Date(checkOut);
  expiration.setDate(expiration.getDate() + expirationDays);

  return admin.firestore.Timestamp.fromDate(expiration);
}

/**
 * Verify if access token matches stored hash
 *
 * SECURITY:
 * - Input validation prevents invalid data from reaching crypto operations
 * - Format validation rejects malformed tokens early
 * - Constant-time comparison prevents timing attacks
 * - Minimal logging to prevent information leakage
 *
 * @param providedToken - Token from user (plaintext from URL/email)
 * @param storedHash - SHA-256 hash from database
 * @returns true if token matches hash, false otherwise
 */
export function verifyAccessToken(
  providedToken: string | null | undefined,
  storedHash: string | null | undefined
): boolean {
  // ========================================================================
  // STEP 1: VALIDATE INPUT PARAMETERS
  // ========================================================================

  // Check: Is providedToken valid?
  if (!providedToken || typeof providedToken !== "string") {
    console.warn("[Security] Token verification failed: invalid providedToken (empty or not string)");
    return false;
  }

  // Check: Is storedHash valid?
  if (!storedHash || typeof storedHash !== "string") {
    console.warn("[Security] Token verification failed: invalid storedHash (empty or not string)");
    return false;
  }

  // Check: Token length using configured bounds
  if (providedToken.length < MIN_TOKEN_LENGTH ||
      providedToken.length > MAX_TOKEN_LENGTH) {
    console.warn("[Security] Token verification failed: invalid token length", {
      length: providedToken.length,
      expectedRange: `${MIN_TOKEN_LENGTH}-${MAX_TOKEN_LENGTH}`,
    });
    return false;
  }

  // Check: Is storedHash valid hex string? (SHA-256 = exactly 64 hex chars)
  if (storedHash.length !== HASH_LENGTH ||
      !/^[0-9a-f]+$/i.test(storedHash)) {
    console.warn("[Security] Token verification failed: invalid hash format", {
      hashLength: storedHash.length,
      expectedLength: HASH_LENGTH,
      isValidHex: /^[0-9a-f]+$/i.test(storedHash),
    });
    return false;
  }

  // ========================================================================
  // STEP 2: HASH PROVIDED TOKEN
  // ========================================================================
  let hashedProvidedToken: string;
  try {
    hashedProvidedToken = crypto
      .createHash("sha256")
      .update(providedToken)
      .digest("hex");
  } catch (error) {
    // This should never happen with valid strings, but catch just in case
    console.error("[Security] Token hashing failed", {
      error: error instanceof Error ? error.message : "Unknown error",
      providedTokenLength: providedToken.length,
    });
    return false;
  }

  // ========================================================================
  // STEP 3: CONSTANT-TIME COMPARISON (prevents timing attacks)
  // ========================================================================
  try {
    const result = crypto.timingSafeEqual(
      Buffer.from(hashedProvidedToken, "hex"),
      Buffer.from(storedHash, "hex")
    );

    // Log ONLY failures for security audit (success is expected, no need to log)
    if (!result) {
      console.warn("[Security] Token verification failed: hash mismatch", {
        providedTokenLength: providedToken.length,
        timestamp: new Date().toISOString(),
      });
    }

    return result;
  } catch (error) {
    // This catch should be unreachable now (we validated lengths above)
    // but keep it as final safety net
    console.error("[Security] Token comparison error", {
      error: error instanceof Error ? error.message : "Unknown error",
      hashedTokenLength: hashedProvidedToken.length,
      storedHashLength: storedHash.length,
    });
    return false;
  }
}
