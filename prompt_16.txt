PROMPT 16: Error Handling & Logging

Implementiraj robust error handling system:

1. CUSTOM EXCEPTIONS (`lib/core/errors/exceptions.dart`):
```dart
abstract class AppException implements Exception {
  final String message;
  final String? code;
  final dynamic details;

  AppException(this.message, {this.code, this.details});

  @override
  String toString() => 'AppException: $message (code: $code)';
}

class NetworkException extends AppException {
  NetworkException(String message, {String? code, dynamic details})
      : super(message, code: code, details: details);
}

class AuthException extends AppException {
  AuthException(String message, {String? code, dynamic details})
      : super(message, code: code, details: details);
}

class DatabaseException extends AppException {
  DatabaseException(String message, {String? code, dynamic details})
      : super(message, code: code, details: details);
}

class ValidationException extends AppException {
  ValidationException(String message, {String? code, dynamic details})
      : super(message, code: code, details: details);
}

class PaymentException extends AppException {
  PaymentException(String message, {String? code, dynamic details})
      : super(message, code: code, details: details);
}
```

2. ERROR HANDLER (`lib/core/errors/error_handler.dart`):
```dart
class ErrorHandler {
  static String getUserMessage(dynamic error) {
    // Convert technical errors to user-friendly messages
    if (error is NetworkException) {
      return 'Provjerite internet konekciju i pokušajte ponovo.';
    } else if (error is AuthException) {
      return 'Greška prilikom autentifikacije. Molimo prijavite se ponovo.';
    }
    // ... ostale error types
    return 'Došlo je do neočekivane greške. Pokušajte ponovo.';
  }

  static void logError(dynamic error, StackTrace stackTrace) {
    // Log to console in dev, to service in prod
    if (kDebugMode) {
      debugPrint('Error: $error');
      debugPrint('StackTrace: $stackTrace');
    } else {
      // Send to error tracking service (Sentry, Firebase Crashlytics)
      // await Sentry.captureException(error, stackTrace: stackTrace);
    }
  }

  static void showErrorDialog(BuildContext context, dynamic error) {
    // Show dialog sa error message
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('Greška'),
        content: Text(getUserMessage(error)),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text('OK'),
          ),
        ],
      ),
    );
  }
}
```

ERROR HANDLING UTILITIES (Original - sa kompletnim metodama) (`lib/core/errors/error_handler.dart`):

```dart
class ErrorHandler {
  static String getUserFriendlyMessage(dynamic error) {
    if (error is NetworkException) {
      return 'Provjerite internet konekciju i pokušajte ponovo.';
    } else if (error is AuthException) {
      return 'Greška prilikom autentifikacije. Molimo prijavite se ponovo.';
    } else if (error is DatabaseException) {
      return 'Greška u bazi podataka. Pokušajte ponovo.';
    } else if (error is ValidationException) {
      return error.message;
    } else if (error is PaymentException) {
      return 'Greška prilikom plaćanja: ${error.message}';
    } else {
      return 'Došlo je do neočekivane greške. Pokušajte ponovo.';
    }
  }

  static void showErrorSnackBar(BuildContext context, dynamic error) {
    final message = getUserFriendlyMessage(error);
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.red,
        duration: Duration(seconds: 4),
        action: SnackBarAction(
          label: 'OK',
          textColor: Colors.white,
          onPressed: () {},
        ),
      ),
    );
  }

  static Future<void> logError(dynamic error, StackTrace? stackTrace) async {
    // Log to console in debug mode
    debugPrint('Error: $error');
    debugPrint('StackTrace: $stackTrace');

    // TODO: Send to error tracking service (Sentry, Firebase Crashlytics)
    // await Sentry.captureException(error, stackTrace: stackTrace);
  }
}
```

3. RIVERPOD ERROR HANDLING:

   Wrapper za async operations:
   ```dart
   Future<AsyncValue<T>> executeAsync<T>(
     Future<T> Function() operation,
   ) async {
     try {
       final result = await operation();
       return AsyncValue.data(result);
     } catch (error, stackTrace) {
       ErrorHandler.logError(error, stackTrace);
       return AsyncValue.error(error, stackTrace);
     }
   }

   // Usage example:
   @riverpod
   class PropertiesNotifier extends _$PropertiesNotifier {
     @override
     Future<List<Property>> build() async {
       return executeAsync(() async {
         final result = await ref.read(propertyRepositoryProvider).fetchProperties();
         return result.when(
           success: (data) => data,
           failure: (exception) => throw exception,
         );
       }).then((asyncValue) => asyncValue.value!);
     }
   }
   ```

4. GLOBAL ERROR WIDGET:
   ```dart
   class ErrorWidget extends StatelessWidget {
     final String message;
     final VoidCallback? onRetry;

     const ErrorWidget({
       Key? key,
       required this.message,
       this.onRetry,
     }) : super(key: key);

     @override
     Widget build(BuildContext context) {
       return Center(
         child: Padding(
           padding: const EdgeInsets.all(24.0),
           child: Column(
             mainAxisAlignment: MainAxisAlignment.center,
             children: [
               Icon(Icons.error_outline, size: 64, color: Colors.red),
               SizedBox(height: 16),
               Text(
                 message,
                 textAlign: TextAlign.center,
                 style: Theme.of(context).textTheme.titleMedium,
               ),
               if (onRetry != null) ...[
                 SizedBox(height: 24),
                 ElevatedButton.icon(
                   onPressed: onRetry,
                   icon: Icon(Icons.refresh),
                   label: Text('Pokušaj ponovo'),
                 ),
               ],
             ],
           ),
         ),
       );
     }
   }
   ```

5. RESULT TYPE (Functional Error Handling):

`lib/core/utils/result.dart`:
```dart
abstract class Result<T> {
  const Result();
}

class Success<T> extends Result<T> {
  final T data;
  const Success(this.data);
}

class Failure<T> extends Result<T> {
  final AppException exception;
  const Failure(this.exception);
}

// Extension methods for convenient handling
extension ResultExtension<T> on Result<T> {
  bool get isSuccess => this is Success<T>;
  bool get isFailure => this is Failure<T>;

  T? get dataOrNull => this is Success<T> ? (this as Success<T>).data : null;
  AppException? get exceptionOrNull =>
      this is Failure<T> ? (this as Failure<T>).exception : null;

  R when<R>({
    required R Function(T data) success,
    required R Function(AppException exception) failure,
  }) {
    if (this is Success<T>) {
      return success((this as Success<T>).data);
    } else {
      return failure((this as Failure<T>).exception);
    }
  }
}
```

6. REPOSITORY ERROR HANDLING EXAMPLE:

```dart
class PropertyRepositoryImpl implements PropertyRepository {
  final SupabaseClient _client;

  @override
  Future<Result<List<Property>>> fetchProperties() async {
    try {
      final response = await _client
          .from('properties')
          .select()
          .execute();

      if (response.error != null) {
        return Failure(DatabaseException(
          response.error!.message,
          code: response.error!.code,
        ));
      }

      final properties = (response.data as List)
          .map((json) => Property.fromJson(json))
          .toList();

      return Success(properties);
    } on SocketException {
      return Failure(NetworkException('Nema internet konekcije'));
    } catch (e) {
      await ErrorHandler.logError(e, StackTrace.current);
      return Failure(DatabaseException('Greška prilikom dohvaćanja podataka'));
    }
  }
}
```

7. PROVIDER ERROR HANDLING PATTERN:

```dart
@riverpod
class PropertiesNotifier extends _$PropertiesNotifier {
  @override
  Future<List<Property>> build() async {
    final result = await ref.read(propertyRepositoryProvider).fetchProperties();

    return result.when(
      success: (properties) => properties,
      failure: (exception) {
        ErrorHandler.logError(exception, StackTrace.current);
        throw exception;
      },
    );
  }
}

// In UI:
Consumer(
  builder: (context, ref, child) {
    final propertiesAsync = ref.watch(propertiesNotifierProvider);

    return propertiesAsync.when(
      data: (properties) => PropertyListView(properties),
      loading: () => CircularProgressIndicator(),
      error: (error, stackTrace) {
        ErrorHandler.showErrorSnackBar(context, error);
        return ErrorStateWidget(
          message: ErrorHandler.getUserFriendlyMessage(error),
          onRetry: () => ref.invalidate(propertiesNotifierProvider),
        );
      },
    );
  },
)
```

8. LOGGING SERVICE (Optional):

`lib/core/services/logging_service.dart`:
```dart
class LoggingService {
  static void log(String message, {String? tag}) {
    debugPrint('[${tag ?? 'APP'}] $message');
  }

  static void logInfo(String message) {
    log(message, tag: 'INFO');
  }

  static void logWarning(String message) {
    log(message, tag: 'WARNING');
  }

  static void logError(String message, [dynamic error, StackTrace? stackTrace]) {
    log(message, tag: 'ERROR');
    if (error != null) {
      debugPrint('Error details: $error');
    }
    if (stackTrace != null) {
      debugPrint('StackTrace: $stackTrace');
    }
  }
}
```

9. ERROR WIDGETS (Original):

`lib/shared/widgets/error_state_widget.dart`:
```dart
class ErrorStateWidget extends StatelessWidget {
  final String message;
  final VoidCallback? onRetry;

  const ErrorStateWidget({
    Key? key,
    required this.message,
    this.onRetry,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error_outline, size: 64, color: Colors.red),
            SizedBox(height: 16),
            Text(
              message,
              textAlign: TextAlign.center,
              style: Theme.of(context).textTheme.titleMedium,
            ),
            if (onRetry != null) ...[
              SizedBox(height: 24),
              ElevatedButton.icon(
                onPressed: onRetry,
                icon: Icon(Icons.refresh),
                label: Text('Pokušaj ponovo'),
              ),
            ],
          ],
        ),
      ),
    );
  }
}
```

10. ANALYTICS & LOGGING:

   Setup za:
   - Firebase Crashlytics (optional)
   - Sentry integration
   - Custom event logging

   `lib/core/services/analytics_service.dart`:
   ```dart
   class AnalyticsService {
     // Firebase Crashlytics setup
     static Future<void> initializeCrashlytics() async {
       // await FirebaseCrashlytics.instance.setCrashlyticsCollectionEnabled(true);
       // FlutterError.onError = FirebaseCrashlytics.instance.recordFlutterError;
     }

     // Sentry setup
     static Future<void> initializeSentry() async {
       // await SentryFlutter.init(
       //   (options) {
       //     options.dsn = 'YOUR_SENTRY_DSN';
       //     options.tracesSampleRate = 1.0;
       //   },
       // );
     }

     // Custom event logging
     static void logEvent(String eventName, {Map<String, dynamic>? parameters}) {
       debugPrint('Analytics Event: $eventName, params: $parameters');
       // await FirebaseAnalytics.instance.logEvent(
       //   name: eventName,
       //   parameters: parameters,
       // );
     }

     // Screen view tracking
     static void logScreenView(String screenName) {
       logEvent('screen_view', parameters: {'screen_name': screenName});
     }

     // User properties
     static void setUserId(String userId) {
       // await FirebaseAnalytics.instance.setUserId(id: userId);
     }

     // Custom error tracking
     static Future<void> reportError(dynamic error, StackTrace? stackTrace) async {
       debugPrint('Reporting error: $error');
       // await FirebaseCrashlytics.instance.recordError(error, stackTrace);
       // await Sentry.captureException(error, stackTrace: stackTrace);
     }
   }
   ```

Implementiraj sa unit tests.

DELIVERABLES:
- Custom exception classes hierarchy
- ErrorHandler utility class
- Result type za functional error handling
- Repository error handling examples
- Provider error handling pattern
- Riverpod async wrapper (executeAsync)
- Global error widget
- Logging service
- Analytics & error tracking setup (Firebase/Sentry)
- Error state widgets
- User-friendly error messages (na hrvatskom/srpskom)
- Integration sa error tracking service (prepared for Sentry/Firebase)
- Unit tests za error handling logic
